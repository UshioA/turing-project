\documentclass[utf8]{article}
\usepackage{ctex}
\usepackage{geometry}
\usepackage{fontspec}
\usepackage{ulem}
\usepackage{minted}
\usepackage{algorithm}
\usepackage{algorithmic}
\usepackage{hyperref}
\usepackage{xcolor}
\usepackage{graphicx}
\geometry{a4paper, scale=0.7}
\hypersetup{
    colorlinks,
    linkbordercolor = {white},
    linkcolor=black,
    anchorcolor=black,
    citecolor=black,
    urlcolor=black
}
\setminted{
  fontsize=\small,
  breaklines=true,
}

\title{\textbf{FLA课程实验报告}}
\author{people}
\date{114514}

\begin{document}
\maketitle
\newpage
\tableofcontents
\newpage
\section[分析与设计]{分析与设计思路}
\subsection[解析器]{设计解析器}
解析器被设计为两部分:一部分是解析输入, 另一部分是检查输入的有效性. 第一部分先于第二部分执行. 设计成这样的原因是输入中的错误可以分为两类, 其一是词法错误, 其二是语法错误. 词法错误不需要更多的信息就能马上决定: 在\#后面使用了不支持的
符号, 使用的字符不在合法的字符范围内, 在不该引入空格的地方引入了空格之类的. 然而, 语法错误需要更多信息才能判定, 所以不能很快就检测它. 比如, 用户可能先声明final\_states, 再去声明所有的states, 如果在载入final\_states的过程
中急了, 告诉用户你的final\_states不在Q当中, 用户就会变得生气而不再使用这个程序, 退一步说, 这样的程序行为也不是正确的: 它错误地判断一个可能合法的程序不合法. 因此, 比较好的行为是先一口气读入所有的程序文本, 在解析器内部保存从这个
文本里获取到的信息, 再分析各个组分之间可能存在的矛盾, 这时候得到的信息就是准确无误的了. 

于是, 设计\verb|tm_parser|类, 它接受一个\verb|input|字符串参数来初始化. \verb|parser|类同时也会new一个\verb|turing_machine|, 
\verb|turing_machine|的设计放在下一节讲, 此处只需要知道它暴露了可以修改其组成成分的各种接口即可. \verb|tm_parser|在其析构函数里析构\verb|turing_machine|. 这是RAII的, 因此即使中途丢出异常, 也不会导致内存泄漏.

然后, \verb|tm_parser|通过成员函数\verb|eat_input|来对输入进行分析, 并抛出它遇到的第一个词法错误. 若分析完了也没发现语法错误, 则可以进入接下来的阶段. \verb|eat_input|函数边分析边构造图灵机的组分: 在自身存储
的拷贝上构造. 具体来说, 它使用一系列工具函数来完成分析. \verb|eat_input|本身是一个大循环, 它在输入字符串没被分析完之前会一直循环, 如果它遇到一个分号, 说明接下来的都是注释, 调用\verb|skip_comment|来跳过一整行. 
如果它遇到\verb|#|符号, 说明接下来的一行会描述图灵机的一种组成, 通过一个\verb|switch|语句来判别各种情况. 如果不是前述两种, 则assume接下来的是一个transition. 对于transition, 调用\verb|delta|函数来返回一个
描述转移函数的结构体. 

如果上述过程执行顺利, 没有遇到词法错误, 则函数返回时, \verb|tm_parser|就已经成功的将输入字符串转化为了对应的图灵机描述信息, 然而, 这信息仍然可能是不合法的, 因此需要进一步检查是否存在语法错误. 检查的过程相当无聊, 其实就是
检查某条件是否成立, 如果不成立就抛出一个异常. 所以在类中定义了一个封装这个过程的函数\verb|throw_if|, 它接受一个异常对象, 一个判定函数, 一个判定是否为真的变量, 如果假了就丢出那个异常. \verb|parse|函数首先进行检查, 
若检查无误就把得到的信息写入\verb|turing_machine|. 一共执行了这样一些检查:
\begin{itemize}
  \item 图灵机的所有部分都要被初始化, 也就是说, 不能缺任何一种以\verb|#|开头的语句. 
  \item 初始状态和F需要在Q当中.
  \item 空格符号需要在G当中.
  \item 对于每一个转移函数, 其状态部分需要在Q当中, 纸带上的内容需要在G当中, 方向需要合法. 并且其宽度需要与N匹配. (N的合法性在第一个阶段就可以确定, 保证它至少为1即可)
\end{itemize}
这些检查中的任何一个fail就会立马抛出异常. 如果都没有fail, 则\verb|parser|将得到的信息添加进图灵机. \verb|parser|同时还会添加一个特殊的状态, 其状态名是空串. 这个状态被用作``死亡'', 如果没有任何可用转移, 就跳转到
这个状态, 图灵机发现处于这个状态就会停机. 

最后还需要设计一个\verb|error|类型, 这样外面的调用者catch到之后可以获得足够的信息输出. 一个\verb|error|结构体包含一个字符串, 描述错在哪里, 另一个字符串, 包含相关代码片段, 此片段在代码中的位置信息, 以及错误类型. 
\subsection[图灵机]{设计图灵机}
设计\verb|turing_machine|来模拟图灵机. 在类的内部采用一系列\verb|set|来代表Q, F, S, G四个组成成分, 并使用一个\verb|map|来储存转移函数. 对于纸带, 则采用\verb|vector<tm_tape>|来模拟, 其中\verb|tm_tape|为
自定义类型, 对\verb|vector|进行了封装, 使其支持自动\verb|resize|和负下标访问, 模拟图灵机无限长的纸带. 同时, 为了方便维护``可打印部分'', 对纸带的指针也进行了简单的重载. 

\verb|turing_machine|里有一系列\verb|add_*|和\verb|set_*|函数, 为暴露给外界的接口, 用来更新组成成分. 这主要是给\verb|parser|用的.

此图灵机类被设计为一个最基础的只提供了验证输入合法性, 单步执行, 打印第一条纸带上当前内容, 查看是否停机, 返回当前id功能的模拟器. 它仅忠实地运行, 不负责打印等其他功能. 
具体来说, \verb|validate_input|检查输入, 不合法就丢一个异常出去, 合法就设置第一条纸带内容, \verb|one_step|尝试为当前状态匹配一个转移函数, 如果匹配到了, 就执行这个转移函数, 否则就
当场死亡. \verb|is_halt|函数检查当前状态是不是死状态, 是就返回true. \verb|do_print|函数打印第一条纸带上的可见内容. \verb|get_id|函数返回当前纸带的内容, 当前指针位置和当前状态. 

图灵机也有自己的\verb|error|类型, 因为错误类型单一, 所以它只包含两个成员, 一个\verb|string|, 是输入, 另一个是\verb|int|, 用来指出错误的字符位置. 

\subsection[模拟器]{设计模拟器}
设计\verb|runner|类来管理上面的类. 其实没什么好说的,
 一部分内容是按照上面说的方式, 首先吃进程序, 产生图灵机, 然后验证输入, 然后模拟图灵机运行并输出结果. 以上说明中, 总是说丢出异常, 而不说异常
在哪里被处理, 它就是在\verb|runner|中被处理的. runner对于\verb|parser|丢出的异常, 首先判断类型, 然后打印相关信息并退出程序. 对于\verb|turing_machine|丢出的异常, 则简单的指出错误的位置, 
然后就退出程序. 当然, 如果不是verbose模式, 则仅打印简单的信息就退出. 

\verb|runner|所做的另一部分事情, 则是在verbose模式下产生符合课程要求的打印. 为了做到对齐, 采用了最暴力的计算宽度并填充空格的方式, 简单点说, 就是动态的计算打印内容的可变部分的宽度, 并使用cpp标准库
中的setw函数自动填充适当数量的空格. 对于在下一行需要用\verb|^|来指示的情形, 则在上一行的打印中计算需要的宽度, 在下一行的打印中动态调整\verb|^|的位置. 最终得到的程序和Github上的某标程对拍, 没有出现不一样的地方, 感觉
效果还行. 

\subsection[任务三]{任务三程序实现思路}
\subsubsection[一]{case1.tm}
此问题为循环右移. 采用最暴力的想法, 首先将输入的前n-1个字符直接写到后n-1个字符上, 再将其最后一个字符写到第一个位置. 
对于第一步, 可以首先将输入复制到另一条纸带上, 然后将内容错开一位倒着写回去即可, 对于第二步, 采用奢侈的第三条纸带, 在复制到最后一个字符的时候, 不仅复制到
第二条纸带, 同时也复制到第三条纸带, 这样, 在写回到最后一个字符的下一步, 将第三条纸带上的内容写回到第一条纸带的第一个位置, 就完成了循环右移操作. 
\subsubsection[二]{case2.tm}
乍看之下, 判断完全平方数有点难以下手. 不过, 考虑此结论:
\[
n^2 = \sum_{k=1}^{n} (2k-1)
\]
就得到一个解决问题的办法. 
因为题目要求原地输出, 所以首先一边将第一条纸带内容复制到第二条一边擦除第一条纸带的内容, 然后将两条纸带的指针都归0. 然后, 在第三条纸带上, 首先写入一个1, 然后重复此过程
\begin{itemize}
  \item 在第三条纸带上, 从一连串1的一端开始向另一端移动指针, 与此同时, 擦除第二条纸带的1, 并向右移动指针.
  \item 如果第三条纸带的指针没有指向空格, 但是第二条纸带已经空了, 说明不是完全平方数, reject
  \item 如果第三条纸带的指针指向了空格, 而且第二条纸带空了, 则证明了第二条纸带是完全平方数, accept
  \item 如果第三条纸带的指针指向空格, 但是第二条纸带并没有空, 就在那一连串1后面再写2个1, 然后调转指针方向, 重复第一步. 
\end{itemize}
以上过程的本质是不断的从输入的1上减去奇数个1, 以验证上面给出的结论, 所以其正确性是有保证的. 
\section{实验完成度}
完成了任务一的必做和选做, 任务二的普通模式和verbose模式, 任务三的两个程序. 并且通过了群里某\hyperlink{https://www.baidu.com}{永雏塔菲}提供的测试集. 
\section{实验中遇到的问题和解决方案}
\subsection{问题1}
维护可见范围指针的时候, 一开始准备根据纸带内容动态维护, 非常复杂, 代码不好写, 所以后面直接采取了暴力实现. 考虑到测试的时候纸带实际被使用的范围很小, 其代价
是可以接受的. 
\subsection{问题2}
一开始没看清楚文档, 凭借经验觉得\verb|*|的语义是通配符, 而不是不能匹配空格, 结果在跑一些测试样例以及撰写自定义程序的时候都遇到了错误. 解决方案是改过来.
\section{总结感想}
图灵机真是太有意思了. 
\section{对课程和实验的意见与建议}
对输出格式的要求实在是太严格了, 感觉不是很有必要, 希望能放松这方面的要求. cpp的许多标准库都只能说差强人意, 要是能适当开放使用第三方库就太好了. 
\end{document}

